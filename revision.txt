ğŸ“š FICHE DE RÃ‰VISION - ARCHITECTURE BACKEND SPRING BOOT
ğŸ¯ Vue d'ensemble
Une application Spring Boot suit une architecture en 3 couches pour sÃ©parer les responsabilitÃ©s :
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   COUCHE PRÃ‰SENTATION (REST)        â”‚  â† Communication avec l'extÃ©rieur
â”‚   @RestController                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   COUCHE SERVICE (MÃ‰TIER)            â”‚  â† Logique et rÃ¨gles mÃ©tier
â”‚   @Service                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   COUCHE PERSISTANCE (DATA)          â”‚  â† AccÃ¨s aux donnÃ©es
â”‚   @Repository                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â†“
         [BASE DE DONNÃ‰ES]

ğŸŒ 1. REST API - Concepts fondamentaux
Qu'est-ce que REST ?
REST (Representational State Transfer) est un style d'architecture, pas un framework :

Chaque ressource est identifiable par une URL unique
Utilise les mÃ©thodes HTTP standard : GET, POST, PUT, DELETE
Communication via protocole HTTP

Exemple d'appel REST
// RequÃªte
GET https://api.fakecompany.com/v1/users/1234

// RÃ©ponse
{"id":"1234", "name":"John Doe"}
Les mÃ©thodes HTTP (verbes)
MÃ©thodeUsageExempleGETRÃ©cupÃ©rer une ressourceGET /users/123POSTCrÃ©er une nouvelle ressourcePOST /usersPUTModifier une ressource complÃ¨tePUT /users/123DELETESupprimer une ressourceDELETE /users/123PATCHModifier partiellementPATCH /users/123

ğŸ—ï¸ 2. COUCHE PRÃ‰SENTATION - @RestController
RÃ´le

Point d'entrÃ©e de l'application
ReÃ§oit les requÃªtes HTTP
Appelle la couche service
Retourne les rÃ©ponses au format JSON

Annotations principales
java@RestController  // DÃ©clare la classe comme contrÃ´leur REST
public class HealthCheckController {

    @Autowired  // Injection de dÃ©pendance automatique
    private HealthCheckService healthCheckService;

    @GetMapping("/healthcheck")  // Mappe GET /healthcheck
    public HealthCheck healthcheck() {
        return healthCheckService.healthcheck();
    }
}
Annotations de mapping
java@GetMapping("/path")      // HTTP GET
@PostMapping("/path")     // HTTP POST
@PutMapping("/path")      // HTTP PUT
@DeleteMapping("/path")   // HTTP DELETE
@RequestMapping("/path")  // GÃ©nÃ©rique (tous les verbes)
âš ï¸ Important
Le contrÃ´leur NE DOIT PAS contenir de logique mÃ©tier, il dÃ©lÃ¨gue au service !

ğŸ¯ 3. COUCHE SERVICE - @Service
RÃ´le

Contient toute la logique mÃ©tier
Applique les rÃ¨gles et processus
Orchestre les appels aux repositories
Effectue les calculs et validations

Structure type
java@Service  // Indique que c'est une classe de logique mÃ©tier
public class HealthCheckService {

    @Autowired  // Injection du repository
    private HealthCheckRepository healthCheckRepository;

    public HealthCheck healthcheck() {
        // LOGIQUE MÃ‰TIER ICI
        Long connections = healthCheckRepository.countApplicationConnections();

        if (connections > 0) {
            return new HealthCheck(ApplicationStatus.OK, "Application OK");
        } else {
            return new HealthCheck(ApplicationStatus.KO, "Erreur de connexion");
        }
    }
}
ğŸ“Œ Principe clÃ©
La logique mÃ©tier est dÃ©finie par les experts mÃ©tier et retranscrite en code par les dÃ©veloppeurs.

ğŸ’¾ 4. COUCHE PERSISTANCE - @Repository
RÃ´le

GÃ¨re l'accÃ¨s aux donnÃ©es
Communique avec la base de donnÃ©es
ExÃ©cute les requÃªtes SQL ou utilise JPA
Abstrait la complexitÃ© de la persistance

Structure type
java@Repository  // Indique que cette classe accÃ¨de aux donnÃ©es
public class HealthCheckRepository {

    @Autowired
    private EntityManager entityManager;  // Gestionnaire d'entitÃ©s JPA

    public Long countApplicationConnections() {
        String query = "SELECT count(*) FROM pg_stat_activity " +
                      "WHERE application_name = 'PostgreSQL JDBC Driver'";
        return (Long) entityManager.createNativeQuery(query).getSingleResult();
    }
}
Types de requÃªtes
1. RequÃªte native (SQL pur)
javaentityManager.createNativeQuery("SELECT * FROM users WHERE id = ?")
2. JPQL (Java Persistence Query Language)
javaentityManager.createQuery("SELECT u FROM User u WHERE u.id = :id")

ğŸ”§ 5. CONFIGURATION - application.properties
Configuration de la base de donnÃ©es PostgreSQL
properties# URL de connexion Ã  PostgreSQL
spring.datasource.url=jdbc:postgresql://localhost:5432/postgres

# Identifiants
spring.datasource.username=postgres
spring.datasource.password=postgres

# DÃ©sactive l'Open Session In View (bonne pratique)
spring.jpa.open-in-view=false
ParamÃ¨tres importants
PropriÃ©tÃ©Descriptionspring.datasource.urlURL de connexion JDBCspring.datasource.usernameNom d'utilisateur DBspring.datasource.passwordMot de passe DBspring.jpa.open-in-viewGestion des sessions Hibernate (false = mieux)

ğŸ’‰ 6. INJECTION DE DÃ‰PENDANCES
Concept
Spring gÃ¨re automatiquement la crÃ©ation et l'injection des objets (beans).
Avec @Autowired
java@RestController
public class UserController {

    @Autowired  // Spring injecte automatiquement UserService
    private UserService userService;

    // userService est prÃªt Ã  Ãªtre utilisÃ© !
}
Comment Ã§a marche ?

Spring scanne les classes avec @Component, @Service, @Repository, @RestController
Il crÃ©e des instances (beans) de ces classes
Il les injecte automatiquement lÃ  oÃ¹ c'est nÃ©cessaire avec @Autowired

Les annotations de composants
java@Component      // Composant gÃ©nÃ©rique Spring
@Service        // Composant de logique mÃ©tier
@Repository     // Composant d'accÃ¨s aux donnÃ©es
@RestController // Composant contrÃ´leur REST

ğŸ—‚ï¸ 7. ORGANISATION DES PACKAGES
Structure recommandÃ©e
src/main/java/com/dyma/tennis/
â”‚
â”œâ”€â”€ TennisApplication.java          // Point d'entrÃ©e (@SpringBootApplication)
â”‚
â”œâ”€â”€ rest/                            // COUCHE PRÃ‰SENTATION
â”‚   â””â”€â”€ HealthCheckController.java
â”‚
â”œâ”€â”€ service/                         // COUCHE SERVICE
â”‚   â””â”€â”€ HealthCheckService.java
â”‚
â”œâ”€â”€ repository/                      // COUCHE PERSISTANCE
â”‚   â””â”€â”€ HealthCheckRepository.java
â”‚
â””â”€â”€ model/                           // OBJETS MÃ‰TIER
    â”œâ”€â”€ HealthCheck.java
    â””â”€â”€ ApplicationStatus.java

ğŸ˜ 8. BASE DE DONNÃ‰ES POSTGRESQL AVEC DOCKER
Fichier docker-compose (postgresql.yml)
yamlservices:
  dyma-postgresql:
    image: postgres:15
    container_name: dyma-postgres
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    ports:
      - "5432:5432"
    volumes:
      - dyma-postgres-data:/var/lib/postgresql/data

volumes:
  dyma-postgres-data:
Commandes Docker
bash# DÃ©marrer PostgreSQL
docker-compose -f src/main/docker/postgresql.yml up -d

# ArrÃªter PostgreSQL
docker-compose -f src/main/docker/postgresql.yml down

# Voir les logs
docker logs dyma-postgres

ğŸš€ 9. DÃ‰MARRER L'APPLICATION
Avec Maven Wrapper
bash# Linux/Mac
./mvnw spring-boot:run

# Windows
mvnw.cmd spring-boot:run
VÃ©rifier que Ã§a fonctionne
bash# Test de l'API
curl http://localhost:8080/healthcheck

# RÃ©ponse attendue
{
  "status": "OK",
  "message": "Welcome to Koukaye Tennis"
}

ğŸ“‹ 10. MODÃˆLES DE DONNÃ‰ES (DTOs/Entities)
Record (Java 14+)
javapublic record HealthCheck(ApplicationStatus status, String message) {
    // Constructeur, getters, equals, hashCode, toString gÃ©nÃ©rÃ©s automatiquement
}
Enum
javapublic enum ApplicationStatus {
    OK,    // Application fonctionnelle
    KO;    // Application en erreur
}
Classe Entity (pour JPA)
java@Entity
@Table(name = "players")
public class Player {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    // Getters et setters
}

ğŸ“ 11. ANNOTATIONS ESSENTIELLES - RÃ‰CAPITULATIF
Annotations de composants
AnnotationUsage@SpringBootApplicationPoint d'entrÃ©e de l'app@RestControllerContrÃ´leur REST@ServiceLogique mÃ©tier@RepositoryAccÃ¨s aux donnÃ©es@ComponentComposant Spring gÃ©nÃ©rique
Annotations de mapping
AnnotationUsage@GetMappingMappe requÃªte HTTP GET@PostMappingMappe requÃªte HTTP POST@PutMappingMappe requÃªte HTTP PUT@DeleteMappingMappe requÃªte HTTP DELETE
Annotations de dÃ©pendances
AnnotationUsage@AutowiredInjection de dÃ©pendance
Annotations JPA/Database
AnnotationUsage@EntityClasse mappÃ©e en table DB@TableNom de la table@IdClÃ© primaire@GeneratedValueGÃ©nÃ©ration auto de l'ID@ColumnMapping de colonne

âš¡ 12. DÃ‰PANNAGE - ERREURS COURANTES
âŒ Erreur : "password authentication failed"
Cause : Mauvais identifiants PostgreSQL
Solution :
properties# VÃ©rifier application.properties
spring.datasource.username=postgres
spring.datasource.password=postgres
âŒ Erreur : "Unable to determine Dialect"
Cause : PostgreSQL n'est pas dÃ©marrÃ© ou mauvaise URL
Solutions :

VÃ©rifier que Docker PostgreSQL tourne : docker ps
DÃ©marrer PostgreSQL : docker-compose -f src/main/docker/postgresql.yml up -d
VÃ©rifier l'URL dans application.properties

âŒ Erreur : Port 8080 dÃ©jÃ  utilisÃ©
Solution :
properties# Changer le port dans application.properties
server.port=8081

ğŸ“Š 13. FLUX COMPLET D'UNE REQUÃŠTE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLIENT    â”‚  GET /healthcheck
â”‚  (Browser)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  @RestController                 â”‚
â”‚  HealthCheckController           â”‚
â”‚  - ReÃ§oit la requÃªte HTTP        â”‚
â”‚  - Appelle le service            â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  @Service                        â”‚
â”‚  HealthCheckService              â”‚
â”‚  - Applique la logique mÃ©tier    â”‚
â”‚  - Appelle le repository         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  @Repository                     â”‚
â”‚  HealthCheckRepository           â”‚
â”‚  - ExÃ©cute la requÃªte SQL        â”‚
â”‚  - Retourne les donnÃ©es          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PostgreSQL Database             â”‚
â”‚  - ExÃ©cute la requÃªte            â”‚
â”‚  - Retourne le rÃ©sultat          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â†“
    [Remonte dans l'ordre inverse]
       â”‚
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT                          â”‚
â”‚  ReÃ§oit la rÃ©ponse JSON :        â”‚
â”‚  {                               â”‚
â”‚    "status": "OK",               â”‚
â”‚    "message": "Welcome..."       â”‚
â”‚  }                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ¯ 14. BONNES PRATIQUES
âœ… Ã€ FAIRE

Respecter la sÃ©paration en couches : ne pas mÃ©langer les responsabilitÃ©s
Controller â†’ appelle le service, ne contient PAS de logique
Service â†’ contient toute la logique mÃ©tier
Repository â†’ interagit UNIQUEMENT avec la base de donnÃ©es
Utiliser @Autowired pour l'injection de dÃ©pendances
Nommer clairement les packages : rest, service, repository
Utiliser des DTOs/Records pour les transferts de donnÃ©es

âŒ Ã€ Ã‰VITER

Mettre de la logique mÃ©tier dans le contrÃ´leur
Faire des requÃªtes SQL directement dans le service
MÃ©langer les responsabilitÃ©s des couches
Oublier les annotations (@Service, @Repository, etc.)
Hardcoder les configurations (utiliser application.properties)


ğŸ“ 15. CHECKLIST DE DÃ‰VELOPPEMENT
Pour crÃ©er un nouveau endpoint REST :

 CrÃ©er l'entitÃ©/modÃ¨le dans model/
 CrÃ©er le repository dans repository/ avec @Repository
 CrÃ©er le service dans service/ avec @Service
 CrÃ©er le contrÃ´leur dans rest/ avec @RestController
 Ajouter les annotations de mapping (@GetMapping, etc.)
 Injecter les dÃ©pendances avec @Autowired
 Tester avec curl ou Postman
 VÃ©rifier les logs


ğŸ” 16. EXEMPLE COMPLET - CRUD PLAYER
1. EntitÃ© Player
java@Entity
@Table(name = "players")
public class Player {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private int ranking;

    // Getters et setters
}
2. Repository
java@Repository
public interface PlayerRepository extends JpaRepository<Player, Long> {
    // MÃ©thodes CRUD automatiques : save, findById, findAll, delete, etc.
    List<Player> findByRankingLessThan(int ranking);
}
3. Service
java@Service
public class PlayerService {

    @Autowired
    private PlayerRepository playerRepository;

    public List<Player> getAllPlayers() {
        return playerRepository.findAll();
    }

    public Player createPlayer(Player player) {
        return playerRepository.save(player);
    }

    public Optional<Player> getPlayerById(Long id) {
        return playerRepository.findById(id);
    }
}
4. Controller
java@RestController
@RequestMapping("/api/players")
public class PlayerController {

    @Autowired
    private PlayerService playerService;

    @GetMapping
    public List<Player> getAllPlayers() {
        return playerService.getAllPlayers();
    }

    @GetMapping("/{id}")
    public ResponseEntity<Player> getPlayer(@PathVariable Long id) {
        return playerService.getPlayerById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public Player createPlayer(@RequestBody Player player) {
        return playerService.createPlayer(player);
    }
}

ğŸ“ POINTS CLÃ‰S Ã€ RETENIR

Architecture en 3 couches : REST â†’ Service â†’ Repository
Chaque couche a UN rÃ´le prÃ©cis : prÃ©sentation, logique, donnÃ©es
Spring gÃ¨re l'injection des dÃ©pendances automatiquement
REST = style d'architecture utilisant HTTP
PostgreSQL via Docker pour la persistance
application.properties centralise la configuration
Annotations clÃ©s : @RestController, @Service, @Repository, @Autowired


ğŸ“š RESSOURCES SUPPLÃ‰MENTAIRES

Documentation officielle Spring Boot : https://spring.io/projects/spring-boot
Guide Spring Data JPA : https://spring.io/guides/gs/accessing-data-jpa/
REST API Best Practices : https://restfulapi.net/
PostgreSQL Documentation : https://www.postgresql.org/docs/